{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#about","title":"About","text":"<p>Python Camunda SDK is an implementation of Camunda SDK in Python built on top of the pyzeebe.</p> <p>It simplifies definitions of outbound and inbound connectors and utilises pydantic for data validation.</p> <p>Get started</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p><code>pyzeebe</code>: Zeebe client.</p> <p><code>pydantic</code>: Type hints and data validation.</p> <p><code>loguru</code>: Logging.</p> <p><code>click</code>: Command line utilites.</p>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#installation","title":"Installation","text":"<pre><code>$ pip install python-camunda-sdk\n</code></pre>"},{"location":"quick_start/#guide","title":"Guide","text":"<p>Follow the guide to learn how to create connectors, setup the runtime and generate templates for use in Modeler.</p>"},{"location":"quick_start/catch_message/","title":"Catch connector message","text":"<p>To catch a message from an inbound connector, add an Intermediate Catch event and assign message name and correellation key to those configured on the connector.</p>"},{"location":"quick_start/generate_inbound_template/","title":"Generate inbound template","text":"<p>We can create a template for <code>SleepConnector</code> using</p> <pre><code>$ generate_template example.SleepConnector sleep.json\nGenerated template for example.SleepConnector\n</code></pre> <p>Tip</p> <p>For more info on  template generation see Generate outbound template.</p>"},{"location":"quick_start/generate_inbound_template/#template-conversion","title":"Template conversion","text":"<p><code>SleepConnector</code> class have been converted to a template:</p> <ul> <li><code>name</code> of the template was picked up from <code>ConnectorConfig.name</code></li> <li><code>zeebe:taskDefinition:type</code> was set to <code>ConnectorConfig.type</code> (not visible in Modeler).</li> <li><code>duration</code> field of the <code>SleepConnector</code> was converted into a <code>zeebe:input</code> property.</li> <li>A <code>zeebe:taskHeader</code> with key 'resultVariable' was added to allow users define the name of the variable where the output of the <code>LogConnector.run</code> method will be stored.</li> <li>A 'Message name' and 'Correlation key' inputs were added.</li> </ul> Template renderingTemplate jsonSleepConnector <p></p> example/sleep.json<pre><code>{\n\"$schema\": \"https://unpkg.com/@camunda/zeebe-element-templates-json-schema@0.9.0/resources/schema.json\",\n\"name\": \"Sleep\",\n\"id\": \"a631e9a0-939e-4d73-b78c-34939e44eab0\",\n\"appliesTo\": [\n\"bpmn:ServiceTask\"\n],\n\"properties\": [\n{\n\"binding\": {\n\"type\": \"zeebe:input\",\n\"name\": \"duration\"\n},\n\"label\": \"Duration of sleep in seconds\",\n\"type\": \"String\",\n\"group\": \"input\",\n\"feel\": \"optional\"\n},\n{\n\"binding\": {\n\"type\": \"zeebe:taskHeader\",\n\"key\": \"resultVariable\"\n},\n\"label\": \"Result variable\",\n\"type\": \"String\",\n\"group\": \"output\"\n},\n{\n\"binding\": {\n\"type\": \"zeebe:taskDefinition:type\"\n},\n\"type\": \"Hidden\",\n\"value\": \"sleep\"\n},\n{\n\"binding\": {\n\"type\": \"zeebe:input\",\n\"name\": \"correlation_key\"\n},\n\"label\": \"Correlation key\",\n\"type\": \"String\",\n\"group\": \"config\",\n\"feel\": \"optional\"\n},\n{\n\"binding\": {\n\"type\": \"zeebe:input\",\n\"name\": \"message_name\"\n},\n\"label\": \"Message name\",\n\"type\": \"String\",\n\"group\": \"config\",\n\"feel\": \"optional\"\n}\n],\n\"groups\": [\n{\n\"id\": \"input\",\n\"label\": \"Input\"\n},\n{\n\"id\": \"output\",\n\"label\": \"Output\"\n},\n{\n\"id\": \"config\",\n\"label\": \"Configuration\"\n}\n]\n}\n</code></pre> example/sleep.py<pre><code>import asyncio\nimport random\nfrom pydantic import Field\nfrom python_camunda_sdk import InboundConnector\nclass SleepConnector(InboundConnector):\nduration: int = Field(description=\"Duration of sleep in seconds\")\nasync def run(self, config) -&gt; bool:\nawait asyncio.sleep(self.duration)\nreturn True\nclass ConnectorConfig:\nname=\"Sleep\"\ntype= 'sleep'\n</code></pre>"},{"location":"quick_start/generate_outbound_template/","title":"Generate outbound template","text":"<p>You can generate templates for use in Camunda SaaS or Camunda Modeler from you outbound connectors.</p> <p>Python Camunda SDK includes a <code>generate_template</code> command-line tool to help you.</p> <pre><code>$ generate_template --help\n\nUsage: generate_template [OPTIONS] CONNECTOR FILENAME\n    Generates a template from a CONNECTOR and saves it to FILENAME.\n    CONNECTOR must be a a full class name including the module name, e.g.\n    mymodule.submodule.MyConnector.\nOptions:\n    --help  Show this message and exit.\n</code></pre> <p>For example, if <code>LogConnector</code>, we use in this guide is part of the <code>example</code> module, we can run</p> <pre><code>$ generate_template example.LogConnector log.json\nGenerated template for example.LogConnector\n</code></pre>"},{"location":"quick_start/generate_outbound_template/#template-conversion","title":"Template conversion","text":"<p><code>LogConnector</code> class have been converted to a template:</p> <ul> <li><code>name</code> of the template was picked up from <code>ConnectorConfig.name</code></li> <li><code>zeebe:taskDefinition:type</code> was set to <code>ConnectorConfig.type</code> (not visible in Modeler).</li> <li><code>message</code> field of the <code>LogConnector</code> was converted into a <code>zeebe:input</code> property.</li> <li>A <code>zeebe:taskHeader</code> with key 'resultVariable' was added to allow users define the name of the variable where the output of the <code>LogConnector.run</code> method will be stored.</li> </ul> Template renderingTemplate jsonLogConnector <p></p> example/log.json<pre><code>{\n\"$schema\": \"https://unpkg.com/@camunda/zeebe-element-templates-json-schema@0.9.0/resources/schema.json\",\n\"name\": \"LogConnector\",\n\"id\": \"1d696704-d29c-4a80-94f1-89b8fd3735b7\",\n\"appliesTo\": [\n\"bpmn:ServiceTask\"\n],\n\"properties\": [\n{\n\"binding\": {\n\"type\": \"zeebe:input\",\n\"name\": \"message\"\n},\n\"label\": \"Message to log\",\n\"type\": \"String\",\n\"group\": \"input\",\n\"feel\": \"optional\"\n},\n{\n\"binding\": {\n\"type\": \"zeebe:taskHeader\",\n\"key\": \"resultVariable\"\n},\n\"label\": \"Result variable\",\n\"type\": \"String\",\n\"group\": \"output\"\n},\n{\n\"binding\": {\n\"type\": \"zeebe:taskDefinition:type\"\n},\n\"type\": \"Hidden\",\n\"value\": \"log\"\n}\n],\n\"groups\": [\n{\n\"id\": \"input\",\n\"label\": \"Input\"\n},\n{\n\"id\": \"output\",\n\"label\": \"Output\"\n}\n]\n}\n</code></pre> example/log.py<pre><code>from pydantic import BaseModel, Field\nfrom loguru import logger\nfrom python_camunda_sdk import OutboundConnector\nclass StatusModel(BaseModel):\nstatus: str\nclass LogConnector(OutboundConnector):\nmessage: str = Field(description=\"Message to log\")\nasync def run(self, config) -&gt; StatusModel:\nlogger.info(f\"LogConnector: {self.message}\")\nreturn StatusModel(status=\"ok\")\nclass ConnectorConfig:\nname = \"LogConnector\"\ntype = \"log\"\n</code></pre>"},{"location":"quick_start/generate_outbound_template/#importing-template-to-camunda-saas","title":"Importing template to Camunda SaaS","text":"<p>Open Modeler, and upload the template using New -&gt; Upload files menu.</p>"},{"location":"quick_start/generate_outbound_template/#importing-template-to-camunda-modeler","title":"Importing template to Camunda Modeler","text":"<p>Save the template into <code>resources/element-templates/</code> directory. See Configuring templates in the official Caunda documentation for details.</p>"},{"location":"quick_start/inbound_connectors/","title":"Define an inbound connector","text":"<p>Warning</p> <p>Inbound connectors are experimental. </p> <p>Implementation of inbound connectors is different from the original one.</p> <p>Instead of automatically fetching Intermediate Catch Events from the Operate server, this runtime relies on a process instance activating the inbound connector explicitly using an service task.</p> <p>Once activated, the runtime will create a new async task that will execute the connector logic and publish a message to Zeebe with the result.</p> <p>Similar to outbound connectors, inbound connectors are defined as classes derived from <code>InboundConnector</code>.</p> example/sleep.py<pre><code>import asyncio\nimport random\nfrom pydantic import Field\nfrom python_camunda_sdk import InboundConnector\nclass SleepConnector(InboundConnector):\nduration: int = Field(description=\"Duration of sleep in seconds\")\nasync def run(self, config) -&gt; bool:\nawait asyncio.sleep(self.duration)\nreturn True\nclass ConnectorConfig:\nname=\"Sleep\"\ntype= 'sleep'\n</code></pre> <p>Once started, this connector will sleep for a given duration and then publish a message to Zebee with a name and correlation key configured in Modeler.</p>"},{"location":"quick_start/outbound_connectors/","title":"Define an outbound connector","text":"<p>Outbound connectors are defined as classes derived from <code>OutboundConnector</code>. Bellow is a code of a simple connector that logs messages to console and returns a <code>StatusModel</code> object.</p> <p>Tip</p> <p>Connectors don't have to return a <code>BaseModel</code>. <code>dict</code> or simple types like <code>str</code>, <code>int</code> or <code>float</code> work as well.</p> example/log.py<pre><code>from pydantic import BaseModel, Field\nfrom loguru import logger\nfrom python_camunda_sdk import OutboundConnector\nclass StatusModel(BaseModel):\nstatus: str\nclass LogConnector(OutboundConnector):\nmessage: str = Field(description=\"Message to log\")\nasync def run(self, config) -&gt; StatusModel:\nlogger.info(f\"LogConnector: {self.message}\")\nreturn StatusModel(status=\"ok\")\nclass ConnectorConfig:\nname = \"LogConnector\"\ntype = \"log\"\n</code></pre> <p>Fields on the connector class define inputs to the connector.</p> <p>Tip</p> <p>Using <code>Field</code> is optional but it is recommended to set <code>description</code> as it will be used for template generation.</p> <p>The <code>ConnectorConfig</code> class defines the <code>name</code> of the connector and its <code>type</code>. Both must be specified are used to generate template.</p> <p>Finally, the logic of the connector is defined in a <code>run</code> method. Make sure you annotate the return type.</p> <p>Warning</p> <p>If <code>run</code> returns nothing, make sure you annotate it with <code>async def run(self, config) -&gt; None</code>.</p>"},{"location":"quick_start/setup_runtime/","title":"Setup a runtime","text":""},{"location":"quick_start/setup_runtime/#overview","title":"Overview","text":"<p>Runtime connects to Zeebe instance and listens to service tasks handled by the connectors.</p> <p>Runtime does not discover connectors automatically. You need to let runtime know which connectors you want it to handle by passing connector classes through <code>outbound_connectors</code> argument.</p> runtime.pylog.py <pre><code>from python_camunda_sdk import CamundaRuntime, InsecureConfig\nfrom log import LogConnector\nconfig = InsecureConfig(\nhost=\"127.0.0.1\"\n)\nruntime = CamundaRuntime(\nconfig=config,\noutbound_connectors=[LogConnector]\n)\nif __name__ == \"__main__\":\nruntime.start()\n</code></pre> <pre><code>from pydantic import BaseModel, Field\nfrom loguru import logger\nfrom python_camunda_sdk import OutboundConnector\nclass StatusModel(BaseModel):\nstatus: str\nclass LogConnector(OutboundConnector):\nmessage: str = Field(description=\"Message to log\")\nasync def run(self, config) -&gt; StatusModel:\nlogger.info(f\"LogConnector: {self.message}\")\nreturn StatusModel(status=\"ok\")\nclass ConnectorConfig:\nname = \"LogConnector\"\ntype = \"log\"\n</code></pre>"},{"location":"quick_start/setup_runtime/#configuration","title":"Configuration","text":"<p>In addition to <code>outbiund_connectors</code> you need to give runtime credentials to Zeebe instance.</p>"},{"location":"quick_start/setup_runtime/#with-config-object","title":"With config object","text":"<p>You can pass configuration object with the details of Zeebe instance you want to connect. The examples of supported configs are below.</p> Insecure configSecure configCloud config <pre><code>from python_camunda_sdk import InsecureConfig\nconfig = InsecureConfig(\nhost='127.0.0.1',\nport=26500\n)\n</code></pre> <pre><code>from python_camunda_sdk import SecureConfig\nconfig = SecureConfig(\nhost='127.0.0.1',\nport=26500,\nroot_certificates='''\n    -----BEGIN CERTIFICATE-----\n    xxx\n    -----BEGIN CERTIFICATE-----\n    '''\nprivate_key='''\n    -----BEGIN RSA PRIVATE KEY-----\n    xxx\n    -----BEGIN RSA PRIVATE KEY-----\n    '''\ncertificate_chain=''\n)\n</code></pre> <pre><code>from python_camunda_sdk import CloudConfig\nconfig = CloudConfig(\nclient_id='jYsgv.SryJYQlcpobk-tZZP~2R60xpNY',\nclient_secret='55kddTbk~yZBFb2NH5GtebWHkSoK1z.TG7G1Hn-n.mH_f4ihpZAUop1-sryxHnyV',\ncluster_id='7bc802fc-7bf4-4800-b84a-596628d1ed08'\n)\n</code></pre>"},{"location":"quick_start/setup_runtime/#with-environmental-variables","title":"With environmental variables","text":"<p>You can also use environment variables to configure connection to Zeebe.</p> All connection typesInsecureSecureCloud Variable Description <code>CAMUNDA_CONNECTION_TYPE</code> Connection type Connection type value Description INSECURE Insecure connection to a self-hosted Zeebe SECURE Secure connection to a self-hosted Zeebe CAMUNDA_CLOUD Conneection to Camunda Cloud Variable Description <code>ZEBEE_HOSTNAME</code> Hostname or IP address of Zeebe <code>ZEBEE_PORT</code> The port Zeebe is listening on Variable Description <code>ZEBEE_HOSTNAME</code> Hostname or IP address of Zeebe <code>ZEBEE_PORT</code> The port Zeebe is listening on <code>SSL_ROOT_CA</code> SSL certificate <code>SSL_PRIVATE_KEY</code> SSL private key <code>SSL_CERTIFICATE_CHAIN</code> SSL certificate chain Variable Description <code>CAMUNDA_CLIENT_ID</code> Client id <code>CAMUNDA_CLIENT_SECRET</code> Client seecret <code>CAMUNDA_CLUSTER_ID</code> Camunda cluster id"},{"location":"quick_start/using_templates/","title":"Using templates","text":"<p>In Modeler,</p> <ol> <li>Create a new Service Task.</li> <li>In the right sidebar, click on the <code>+ Select</code> button in the <code>Template</code> section.</li> <li>If template has been uploaded successfully, you should see it in the list.</li> <li>Apply the template.</li> </ol>"}]}